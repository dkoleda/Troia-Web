{% extends "skeleton/_base.html" %}
{% hyde
    title: "Java client library tutorial"
%}

{% block content %}

<div class="row-fluid">
    <div class="span12">
{% restructuredtext %}

===========================================
Java client library
===========================================

How to use
----------
To use Troia service you must create a request with unique ID and service URL configured.
Then you must execute three steps :
 
 - data upload
 - algorithm execution (computeBlocking)
 - results download

It is possible to download results before executing algorithm but that will result in 
worthless data, so you must be sure that you called *computeBlocking* function before 
downloading results. 


Client classes
--------------
Troia client provides classes that assure compatibility between models used in server and client environment.
Beside those classes client also contains factories that allow simple creation of object required by 
Troia server. Those classes are used only for data compatibility in communication with service and do
not create any sort of object model so data verification must be handled in outside code.


Basic classes
------------- 
Category
~~~~~~~~
Category contains information about category name and it misclassification cost.
It also provides, as static constants, default values of misclassification costs for right
and wrong classification, and default category priority. 


GoldLabel
~~~~~~~~~
Represents a correct label, contains object name and name of object category.

Label
~~~~~
Represents single label created by worker.
Contains object name, worker name and category name

MisclassificationCost
~~~~~~~~~~~~~~~~~~~~~
Cost of incorrect classification contains cost value, category from and category to.
Category from holds name of category that was 

Factories
---------
CategoryFactory
~~~~~~~~~~~~~~~
Allows simple creation of category class objects.
The most basic way to do it is to call function **createCategories** with collection
of String objects representing category names. This will result in creation of categories with
given names an default misclassification costs. This is perfect approach if you do not need to 
create nonstandard misclassification cost maps as it allows you to completely ignore this part
of Troia model and simplifies it use. To be able to create more complex classification models
you can simply pass another argument, this time of type Map<String,Map<String,Double>>, representing
misclassification cost matrix. Correct format of this map is that first key indicates from what and second to 
with category  cost is in map. So  if one will call a function *costs.get("CategoryA").get("CategoryB")*, where 
"costs" is correctly formatted misclassification matrix, it will return cost of misclassification in situation when
object that belong to *CateogryA* was classified as *CategoryB*.

MissclassificationCostFactory
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
It's used to create MisclassificationCost basing on input of Category collection. Category 
object in input must contain their misclassification maps in correct format.

TroiaRequest
-----------------
TroiaRequest is most important class in Troia client, it represents single request to service.
Sometimes, especially in Troia inter works descriptions, request may be called Troia model. From client
side request is identified by service URL and request ID. Request object to not contain any data besides
that required for it identification, however it provides access to data stored in Troia server and enables
access to it services. All methods throw IOException if connection to Troia failed.

For more information visit:

.. raw:: html

    <a class="btn btn-info" href="/apidocs">
        <i class="icon-info-sign icon-white"></i>
        Package documentation site
    </a>

Example of implementation
-------------------------
After explaining available functionalities we can now show example of client implementation.
To be able to use this client you must include TroiaJavaClient-1.0.jar in your project libraries.
Then you need to have already generated labels from another part of program as Troia
only analyzes labels and do not provide functionality raleted to label gathering.
To do that you need to write factory that will create objects of *Label* class from data
returned by your label gatherer. Because Label is identified by worker and object name
you must remember to implement simillar identification method in gatherer if possible and
to transform it if not. After that you can create collection of gold labels with are 
in fact objects with known categories, this will rise quality of Troia results and will
make possible to detect misclassification repeated by all workers. This is minimum that 
is required for Troia to execute, so now that we have prepared this data we can create 
request. To do that we need to create *TroiaRequest* object with constructor takes three parameters

 - serviceUrl : URL address of Troia service
 - requestId : Identifier string with must be quinque for each request
 - timeout : Time after with connection with service is considered broken

Example of constructor that creates request called "TestRequest" and connecting to instance
of Troia on localhost is shown below.
::

 try{
  TroiaRequest request = new TroiaRequest("localhost:8080/GetAnotherLabel","TestRequest",1000);
 }catch(MalformedURLException e){
  logger.error("Malformed URL of Troia service");
 }

Then we need to upload our data to server using *loadLabels* and *loadGoldLabels*.
Each of those functions can throw IOException if there are problems with connection
to Troia service provider.
When all data is uploaded to request we finally can tell Troia to run Dawid-Skene
algorithm on our labels. To do that we use *computeBlocking* function, it takes 
one argument that indicates how many times algorithm will be executed for data set.
Usually three executions of algorithm are optimal.
After Dawid-Skene algorithm will process our labels we need to get results and to do that
we can use *majorityVotes* method that will return map that associates object name with
name of category that have highest probability. So to print out categories of processed objects
following code should be written
:: 
 
 Map<String,String> categories = request.majorityVotes();

 Collection<String> categoryNames = categories.keySet();

 for (String categoryName : categoryNames) {
  System.out.println(categoryName+" category is "+categories.get(categoryName));
 }


{% endrestructuredtext %}
    </div>
</div>
{% endblock %}
